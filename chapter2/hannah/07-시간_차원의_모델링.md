### 07 시간 차원의 모델링

**이벤트 소싱**

> 순섣만 보여주고 테이블을 숨기면 상대가 계속 어리둥절할 것이다. 테이블을 보여주면 일반적으로 순서도는 필요 없게 된다. 테이블의 정보만으로도 명백하기 때문이다
> - 프레드 브룩스(Fred Broooks)

- 이벤트 소싱
    - 데이터 모델에 시간 차원을 도입
    - 이벤트 소싱 기반 시스템은 애그리게이트의 수명주기의 모든 변경사항을 문서화하는 이벤트를 유지

1. 검색
    - 과거 정보를 쉽게 프로젝션할 수 있다
2. 분석
    - 필요한 기능을 구현하려면 프로젝션된 모델을 데이터베이스에 유지
3. 원천 데이터
    - 이벤트 소싱 패턴이 작동하려면 객체 상태에 대한 모든 변경사항이 이벤트로 표현되고 저장
    - 이러한 이벤트는 시스템의 원천 데이터가 된다
    - **이벤트 스토어 :** 이벤트를 저장하는 데 사용되는 데이터베이스를 지칭하는 이름
4. 이벤트 스토어
    1. 추가만 가능한 저장소
    2. 이벤트를 수정하거나 삭제할 수 없다
    3. 특정 비즈니스 엔티티에 속한 모든 이벤트를 가져오고 이벤트를 추가

   > 본질적으로 이벤트 소싱 패턴은 새로운 것이 아니다. 금유유 산업에서는 이벤트를 사용하여 원장의 변경사항을 나타낸다. 원장은 트랜잭션을 문서화하는 추가 전용 로그다. 계정 잔액과 같은 현재 상태는 원장의 기록을 ‘프로젝션’해서 언제든지 추론할 수 있다.


**이벤트 소싱 도메인 모델**

- 도메인 모델 : 애그리게이트의 상태 표현 방식을 유지 관리하고 선택 도메인 이벤트를 내보냄
- 이벤트 소싱 도메인 모델 : 애그리게이트의 수명주기를 모델링하기 위해 독점적으로 도메인 이벤트 사용 (애그리게이트 상태에 대한 모든 변경사항은 도메인 이벤트로 표현돼야함
- 단계
    1. 애그리게이트의 도메인 이벤트를 로드
    2. 이벤트를 비즈니스 의사결정을 내리는 데 사용할 수 있는 상태로 프로젝션해서 상태 표현을 재구성
    3. 애그리게이트의 명령을 실행하여 비즈니스 로직을 실행하고 결과적으로 새로운 도메인 이벤트를 생성
    4. 새 도메인 이벤트를 이벤트 스토어에 커밋

> **왜 ‘이벤트 소싱 도메인 모델’일까?**
이벤트를 사용하여 상태 전환(이벤트 소싱 패턴)을 나타내는 것은 도메인 모델의 구성요소가 있는 없든 가능하다. 따라서 필자는 도메인 모델 애그리게이트의 수명주기 변경ㅇ르 나타내기 위해 이벤트 소싱을 사용하고 있음을 명시적으로 보여주는 방법을 선택했다
>
1. 장점
    - 시간 여행
        - 도메인 이벤트의 사용
            - 애그리게이트의 현재 상태를 재구성
            - 애그리게이트의 모든 과거 상태를 복원하는 데도 사용
    - 심오한 통찰력
        - 시스템의 상태와 동작에 대한 깊은 통찰력 제공
        - 기존 이벤트의 데이터를 활용하여 추가 통찰력을 제공할 새로운 프로젝션 방법을 언제든지 추가할 수 있다
    - 감사 로그
        - 애그리게이트 상태에 발생한 모든 것에 대한 강력하게 일관된 감사 로그(audit log)
        - 법률에 따라 일부 비즈니스 도메인은 이러한 감사 로그를 반드시 구현해야 하며 이벤트 소싱은 이를 즉시 제공
    - 고급 낙관적 동시성 제어
        - 고급 낙관적 동시성 모델 : 읽기 데이터가 기록되는 동안 다른 프로세스에 의해 덮어 쓰여지는 경우 예외를 발생
        - 이벤트 스토어에 동시에 추가된 정확한 이벤트를 추출하고 새로운 이벤트가 시도된 작업과 충돌하는지, 또는 추가 이벤트가 관련이 없고 계속 진행하는 것이 안전한지 대해 비즈니스 도메인 주도 의사결정을 내릴 수 있음
2. 단점
    - 학습 곡선
        - 패턴을 성공적으로 구현하려면 팀 교육과 새로운 사고 방식에 익숙해지는 시간이 필요
    - 모델의 진화
        - 이벤트 소싱 모델을 발전시키는 것은 어려울 수 있다
        - 이벤트 소싱의 정의를 엄밀하게 따지면 이벤트는 변경할 수 없다
    - 아키텍처 복잡성
        - 이벤트 소싱을 구현하면 수많은 아키텍처의 ‘유동적인 부분’이 도입되어 전체 설계가 복잡해짐
3. 자주 묻는 질문
    1. 성능
        - 이벤트에서 애그리게이트 상태를 재구성하면 시스템 성능의 부정적인 영향을 준다 이벤트가 추가되면서 성능이 저하된다
        - 답변
            - 프로세스는 이벤트 스토어 내에서 새 이벤트 를 지속적으로 순회하고 해당 프로젝션을 생성하고 캐시에 저장한다
            - 메모리 내 프로젝션이 필요한 경우
                - 프로세스는 캐시에서 현재 상태의 프로젝션을 가져온다
                - 프로세스는 이벤트 스토어에서 스냅숏 버전 이후에 발생한 이벤트를 가져온다
                - 추가 이벤트는 메모리 내 스냅숏에 적용
        - 이 모델은 엄청난 양의 데이터를 생성한다. 확장할 수 있을까?
        - 답변
            - 모든 이벤트는 단일 샤드(shard)에 있어야 한다
                - 샤딩 : 대량의 데이터를 처리하기 위해 데이터 베이스 테이블을 분할하여 물리적으로 서로 다른 곳에 분산 저장 및 조회하는 것
    2. 데이터 삭제
        - 이벤트 스토어는 추가 전용 데이터베이스지만 물리적으로 데이터를 삭제해야하는 경우
            - 페이로드 패턴(forgettable payload pattern) 으로 해결
    3. 이렇게 하면 안될까요…?
        - 텍스트 파일에 로그를 작성하여 감사 로그로 사용할 수 없는 이유
            - 데이터 베이스 트랜잭션이 실패하면 아무도 이전 로그 메시지를 삭제하지 않는다 따라서 이런 로그는 결국 일관성이 없어진다
        - 상태 기반 모델을 계속 사용할 수 업ㅇㅅ지만 동일한 데이터베이스 트랜잭션에서 로그를 로그 테이블에 추가할 수 없는 이유
            - 사람문제임. 그냥.ㅋㅋ…
        - 상태 기반 모델을 계속 사용할 수 없지만 레코드의 스냅숏을 만들어 전용 ‘이력’ 테이블에 복사하는 데이터베이스 트리거를 추가할 수 없는 이유
            - ‘왜’ 필드가 변경되었는지와 같은 비즈니스 컨텍스트를 잃게 된다

**연습문제**

1. A
2. C
3. D
4. 티켓을 열고 닫을 때